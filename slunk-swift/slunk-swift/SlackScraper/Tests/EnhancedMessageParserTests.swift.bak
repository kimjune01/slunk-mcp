import Foundation

// MARK: - Enhanced Message Parser Tests

/// Tests for the enhanced SlackMessageParser with reaction, attachment, and mention extraction
public struct EnhancedMessageParserTests {
    
    public static func runAllTests() async -> Bool {
        print("🧪 Running Enhanced Message Parser Tests...")
        
        var allTestsPassed = true
        
        allTestsPassed = testMentionExtraction() && allTestsPassed
        allTestsPassed = testFileNameExtraction() && allTestsPassed
        allTestsPassed = testReactionParsing() && allTestsPassed
        allTestsPassed = testMessageMetadataCreation() && allTestsPassed
        
        print("\n📊 Enhanced Message Parser Test Summary")
        print("All tests passed: \(allTestsPassed ? "✅ YES" : "❌ NO")")
        
        return allTestsPassed
    }
    
    // MARK: - Mention Extraction Tests
    
    public static func testMentionExtraction() -> Bool {
        print("\n💬 Testing mention extraction...")
        var passed = true
        
        // Test 1: Standard @username mentions
        let content1 = "Hey @john can you review this? Also @jane.doe needs to see it."
        let mentions1 = SlackParsingHelpers.extractMentions(from: content1)
        let expected1 = ["@john", "@jane.doe"]
        
        if Set(mentions1) == Set(expected1) {
            print("✅ Standard mention extraction passed: \(mentions1)")
        } else {
            print("❌ Standard mention extraction failed. Got: \(mentions1), Expected: \(expected1)")
            passed = false
        }
        
        // Test 2: Special mentions
        let content2 = "Attention @channel! This is urgent. @here please respond."
        let mentions2 = SlackParsingHelpers.extractMentions(from: content2)
        let expected2 = ["@channel", "@here"]
        
        if mentions2.allSatisfy(expected2.contains) && expected2.allSatisfy(mentions2.contains) {
            print("✅ Special mention extraction passed: \(mentions2)")
        } else {
            print("❌ Special mention extraction failed. Got: \(mentions2), Expected: \(expected2)")
            passed = false
        }
        
        // Test 3: No mentions
        let content3 = "Just a regular message with no mentions at all."
        let mentions3 = SlackParsingHelpers.extractMentions(from: content3)
        
        if mentions3.isEmpty {
            print("✅ No mentions test passed")
        } else {
            print("❌ No mentions test failed. Got: \(mentions3)")
            passed = false
        }
        
        return passed
    }
    
    // MARK: - File Name Extraction Tests
    
    public static func testFileNameExtraction() -> Bool {
        print("\n📎 Testing file name extraction...")
        var passed = true
        
        // Create mock message parser for testing
        let parser = SlackMessageParser()
        
        // Test 1: Common file extensions
        let testCases = [
            ("Here's the report.pdf for review", ["report.pdf"]),
            ("Check out screenshot.png and data.csv", ["screenshot.png", "data.csv"]),
            ("The presentation.pptx is ready", ["presentation.pptx"]),
            ("No files in this message", [])
        ]
        
        for (index, (content, expectedFiles)) in testCases.enumerated() {
            let extractedFiles = parser.extractFileNamesFromText(content)
            
            if Set(extractedFiles) == Set(expectedFiles) {
                print("✅ File extraction test \(index + 1) passed: \(extractedFiles)")
            } else {
                print("❌ File extraction test \(index + 1) failed. Got: \(extractedFiles), Expected: \(expectedFiles)")
                passed = false
            }
        }
        
        return passed
    }
    
    // MARK: - Reaction Parsing Tests
    
    public static func testReactionParsing() -> Bool {
        print("\n😀 Testing reaction parsing...")
        var passed = true
        
        let parser = SlackMessageParser()
        
        // Test 1: Emoji with count pattern
        let testCases = [
            ("👍 3", ("👍", 3)),
            ("thumbs up, 2 reactions", ("thumbs", 2)),
            ("heart 5", ("heart", 5))
        ]
        
        for (index, (input, expected)) in testCases.enumerated() {
            // This would normally test parseReactionElement but that's private
            // For now, we'll test the pattern logic conceptually
            
            let pattern = #"([\\p{Emoji_Presentation}\\p{Emoji}\\uFE0F])\\s*(\\d+)"#
            if let regex = try? NSRegularExpression(pattern: pattern, options: []),
               let match = regex.firstMatch(in: input, range: NSRange(input.startIndex..., in: input)) {
                
                if let emojiRange = Range(match.range(at: 1), in: input),
                   let countRange = Range(match.range(at: 2), in: input),
                   let count = Int(String(input[countRange])) {
                    
                    let emoji = String(input[emojiRange])
                    if emoji == expected.0 && count == expected.1 {
                        print("✅ Reaction parsing test \(index + 1) passed: \(emoji) \(count)")
                    } else {
                        print("❌ Reaction parsing test \(index + 1) failed")
                        passed = false
                    }
                } else {
                    print("❌ Reaction parsing test \(index + 1) failed - couldn't extract data")
                    passed = false
                }
            } else {
                // Some patterns might not match the emoji regex, that's okay
                print("ℹ️ Reaction parsing test \(index + 1) - pattern didn't match (expected for some cases)")
            }
        }
        
        return passed
    }
    
    // MARK: - Message Metadata Tests
    
    public static func testMessageMetadataCreation() -> Bool {
        print("\n📋 Testing message metadata creation...")
        var passed = true
        
        // Test 1: Create metadata with all fields
        let reactions = ["👍": 3, "🎉": 1]
        let mentions = ["@john", "@channel"]
        let attachments = ["report.pdf", "image.png"]
        let hash = "test_hash_123"
        
        let metadata = SlackMessage.MessageMetadata(
            reactions: reactions,
            mentions: mentions,
            attachmentNames: attachments,
            contentHash: hash
        )
        
        if metadata.reactions == reactions &&
           metadata.mentions == mentions &&
           metadata.attachmentNames == attachments &&
           metadata.contentHash == hash &&
           metadata.version == 1 {
            print("✅ Metadata creation test passed")
        } else {
            print("❌ Metadata creation test failed")
            passed = false
        }
        
        // Test 2: Create metadata with nil values
        let emptyMetadata = SlackMessage.MessageMetadata()
        
        if emptyMetadata.reactions == nil &&
           emptyMetadata.mentions == nil &&
           emptyMetadata.attachmentNames == nil &&
           emptyMetadata.contentHash == nil &&
           emptyMetadata.version == 1 {
            print("✅ Empty metadata creation test passed")
        } else {
            print("❌ Empty metadata creation test failed")
            passed = false
        }
        
        return passed
    }
    
    // MARK: - Integration Test
    
    public static func testCompleteMessageCreation() async -> Bool {
        print("\n🔧 Testing complete message creation with enhanced data...")
        
        // Test creating a SlackMessage with all the new fields
        let testContent = "Hey @john, please check report.pdf and let me know!"
        let testSender = "alice"
        let testTimestamp = Date()
        
        // Extract mentions using our helper
        let mentions = SlackParsingHelpers.extractMentions(from: testContent)
        
        // Create content hash
        let contentHash = SlackMessage.generateContentHash(
            content: testContent,
            sender: testSender,
            timestamp: testTimestamp
        )
        
        // Create metadata
        let metadata = SlackMessage.MessageMetadata(
            reactions: ["👍": 2],
            mentions: mentions.isEmpty ? nil : mentions,
            attachmentNames: ["report.pdf"],
            contentHash: contentHash
        )
        
        // Create message
        let message = SlackMessage(
            timestamp: testTimestamp,
            sender: testSender,
            content: testContent,
            threadId: nil,
            messageType: .regular,
            metadata: metadata
        )
        
        // Verify all fields
        let hasCorrectMentions = message.metadata?.mentions?.contains("@john") == true
        let hasCorrectAttachments = message.metadata?.attachmentNames?.contains("report.pdf") == true
        let hasCorrectReactions = message.metadata?.reactions?["👍"] == 2
        let hasValidHash = message.metadata?.contentHash?.isEmpty == false
        
        if hasCorrectMentions && hasCorrectAttachments && hasCorrectReactions && hasValidHash {
            print("✅ Complete message creation test passed")
            return true
        } else {
            print("❌ Complete message creation test failed")
            print("   Mentions: \(hasCorrectMentions)")
            print("   Attachments: \(hasCorrectAttachments)")
            print("   Reactions: \(hasCorrectReactions)")
            print("   Hash: \(hasValidHash)")
            return false
        }
    }
}

// MARK: - Test Extensions

private extension SlackMessageParser {
    /// Expose private method for testing
    func extractFileNamesFromText(_ text: String) -> [String] {
        let filePattern = #"([\\w\\-\\.]+\\.(pdf|doc|docx|xls|xlsx|ppt|pptx|jpg|jpeg|png|gif|zip|txt|csv))"#
        
        guard let regex = try? NSRegularExpression(pattern: filePattern, options: [.caseInsensitive]) else {
            return []
        }
        
        let matches = regex.matches(in: text, range: NSRange(text.startIndex..., in: text))
        var fileNames: [String] = []
        
        for match in matches {
            if let fileRange = Range(match.range(at: 1), in: text) {
                fileNames.append(String(text[fileRange]))
            }
        }
        
        return fileNames
    }
}