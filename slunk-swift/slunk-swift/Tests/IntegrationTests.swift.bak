import Foundation

// MARK: - Integration Tests for Enhanced Slack Processing

/// Integration tests that verify the complete pipeline from message parsing to deduplication
public struct SlackIntegrationTests {
    
    public static func runAllTests() async -> Bool {
        print("ðŸ§ª Running Slack Integration Tests...")
        
        var allTestsPassed = true
        
        allTestsPassed = await testMessageDeduplication() && allTestsPassed
        allTestsPassed = await testConversationProcessing() && allTestsPassed
        allTestsPassed = testDataModelIntegrity() && allTestsPassed
        
        print("\nðŸ“Š Integration Test Summary")
        print("All tests passed: \(allTestsPassed ? "âœ… YES" : "âŒ NO")")
        
        return allTestsPassed
    }
    
    // MARK: - Message Deduplication Integration
    
    public static func testMessageDeduplication() async -> Bool {
        print("\nðŸ” Testing message deduplication...")
        var passed = true
        
        // Create test messages
        let timestamp = Date()
        let message1 = SlackMessage(
            timestamp: timestamp,
            sender: "alice",
            content: "Hello @bob, check out report.pdf",
            threadId: nil,
            messageType: .regular,
            metadata: SlackMessage.MessageMetadata(
                reactions: ["ðŸ‘": 2],
                mentions: ["@bob"],
                attachmentNames: ["report.pdf"],
                contentHash: SlackMessage.generateContentHash(
                    content: "Hello @bob, check out report.pdf",
                    sender: "alice",
                    timestamp: timestamp
                )
            )
        )
        
        // Same message (should be detected as duplicate)
        let message2 = SlackMessage(
            timestamp: timestamp,
            sender: "alice", 
            content: "Hello @bob, check out report.pdf",
            threadId: nil,
            messageType: .regular,
            metadata: SlackMessage.MessageMetadata(
                reactions: ["ðŸ‘": 2],
                mentions: ["@bob"],
                attachmentNames: ["report.pdf"],
                contentHash: SlackMessage.generateContentHash(
                    content: "Hello @bob, check out report.pdf",
                    sender: "alice",
                    timestamp: timestamp
                )
            )
        )
        
        // Test deduplication key
        if message1.deduplicationKey == message2.deduplicationKey {
            print("âœ… Deduplication key test passed")
        } else {
            print("âŒ Deduplication key test failed")
            print("   Message1 key: \(message1.deduplicationKey)")
            print("   Message2 key: \(message2.deduplicationKey)")
            passed = false
        }
        
        // Test content hash
        if message1.contentHash == message2.contentHash {
            print("âœ… Content hash test passed")
        } else {
            print("âŒ Content hash test failed")
            passed = false
        }
        
        return passed
    }
    
    // MARK: - Conversation Processing Integration
    
    public static func testConversationProcessing() async -> Bool {
        print("\nðŸ’¬ Testing conversation processing...")
        var passed = true
        
        // Create test conversation
        let messages = [
            SlackMessage(
                timestamp: Date(),
                sender: "alice",
                content: "Hey @everyone, the new feature is ready!",
                threadId: nil,
                messageType: .regular,
                metadata: SlackMessage.MessageMetadata(
                    mentions: ["@everyone"]
                )
            ),
            SlackMessage(
                timestamp: Date(timeIntervalSinceNow: 60),
                sender: "bob",
                content: "Great work! ðŸŽ‰",
                threadId: nil,
                messageType: .regular,
                metadata: SlackMessage.MessageMetadata(
                    reactions: ["ðŸŽ‰": 1]
                )
            ),
            SlackMessage(
                timestamp: Date(timeIntervalSinceNow: 120),
                sender: "charlie",
                content: "I've uploaded the documentation.pdf",
                threadId: nil,
                messageType: .regular,
                metadata: SlackMessage.MessageMetadata(
                    attachmentNames: ["documentation.pdf"]
                )
            )
        ]
        
        let conversation = SlackConversation(
            workspace: "test-workspace",
            channel: "#general",
            channelType: .publicChannel,
            messages: messages
        )
        
        // Test conversation validation
        do {
            try conversation.validate()
            print("âœ… Conversation validation passed")
        } catch {
            print("âŒ Conversation validation failed: \(error)")
            passed = false
        }
        
        // Test conversation metadata
        if conversation.messageCount == 3 &&
           conversation.participantCount == 3 &&
           !conversation.workspace.isEmpty &&
           !conversation.channel.isEmpty {
            print("âœ… Conversation metadata test passed")
        } else {
            print("âŒ Conversation metadata test failed")
            print("   Message count: \(conversation.messageCount)")
            print("   Participant count: \(conversation.participantCount)")
            passed = false
        }
        
        return passed
    }
    
    // MARK: - Data Model Integrity
    
    public static func testDataModelIntegrity() -> Bool {
        print("\nðŸ—ï¸ Testing data model integrity...")
        var passed = true
        
        // Test 1: Message with all metadata fields
        let fullMessage = SlackMessage(
            timestamp: Date(),
            sender: "test_user",
            content: "Test message with @mention and file.pdf",
            threadId: "thread_123",
            messageType: .thread,
            metadata: SlackMessage.MessageMetadata(
                reactions: ["ðŸ‘": 5, "â¤ï¸": 2],
                mentions: ["@mention"],
                attachmentNames: ["file.pdf", "image.png"],
                contentHash: "hash123",
                version: 2
            )
        )
        
        // Verify all fields are preserved
        let hasCorrectSender = fullMessage.sender == "test_user"
        let hasCorrectContent = fullMessage.content.contains("@mention")
        let hasCorrectThread = fullMessage.threadId == "thread_123"
        let hasCorrectType = fullMessage.messageType == .thread
        let hasCorrectReactions = fullMessage.metadata?.reactions?.count == 2
        let hasCorrectMentions = fullMessage.metadata?.mentions?.first == "@mention"
        let hasCorrectAttachments = fullMessage.metadata?.attachmentNames?.count == 2
        let hasCorrectHash = fullMessage.metadata?.contentHash == "hash123"
        let hasCorrectVersion = fullMessage.metadata?.version == 2
        
        if hasCorrectSender && hasCorrectContent && hasCorrectThread && 
           hasCorrectType && hasCorrectReactions && hasCorrectMentions && 
           hasCorrectAttachments && hasCorrectHash && hasCorrectVersion {
            print("âœ… Full message integrity test passed")
        } else {
            print("âŒ Full message integrity test failed")
            print("   Sender: \(hasCorrectSender)")
            print("   Content: \(hasCorrectContent)")
            print("   Thread: \(hasCorrectThread)")
            print("   Type: \(hasCorrectType)")
            print("   Reactions: \(hasCorrectReactions)")
            print("   Mentions: \(hasCorrectMentions)")
            print("   Attachments: \(hasCorrectAttachments)")
            print("   Hash: \(hasCorrectHash)")
            print("   Version: \(hasCorrectVersion)")
            passed = false
        }
        
        // Test 2: Message update functionality
        let updatedMessage = fullMessage.createUpdatedVersion(
            newContent: "Updated test message with @newmention",
            editedAt: Date()
        )
        
        if updatedMessage.content == "Updated test message with @newmention" &&
           updatedMessage.metadata?.version == 3 &&
           updatedMessage.metadata?.editedAt != nil &&
           updatedMessage.id == fullMessage.id { // ID should remain the same
            print("âœ… Message update test passed")
        } else {
            print("âŒ Message update test failed")
            passed = false
        }
        
        // Test 3: Reaction update functionality
        let newReactions = ["ðŸ‘": 10, "ðŸŽ‰": 3]
        let reactionsUpdatedMessage = fullMessage.updateReactions(newReactions)
        
        if reactionsUpdatedMessage.metadata?.reactions == newReactions &&
           reactionsUpdatedMessage.content == fullMessage.content { // Content unchanged
            print("âœ… Reaction update test passed")
        } else {
            print("âŒ Reaction update test failed")
            passed = false
        }
        
        return passed
    }
    
    // MARK: - Performance and Edge Cases
    
    public static func testEdgeCases() -> Bool {
        print("\nðŸ§© Testing edge cases...")
        var passed = true
        
        // Test 1: Empty content
        let emptyMessage = SlackMessage(
            timestamp: Date(),
            sender: "user",
            content: "",
            threadId: nil,
            messageType: .regular
        )
        
        // Should still have valid deduplication key
        if !emptyMessage.deduplicationKey.isEmpty {
            print("âœ… Empty content test passed")
        } else {
            print("âŒ Empty content test failed")
            passed = false
        }
        
        // Test 2: Very long content
        let longContent = String(repeating: "A", count: 10000)
        let longMessage = SlackMessage(
            timestamp: Date(),
            sender: "user",
            content: longContent,
            threadId: nil,
            messageType: .regular
        )
        
        if longMessage.contentHash.count > 0 {
            print("âœ… Long content test passed")
        } else {
            print("âŒ Long content test failed")
            passed = false
        }
        
        // Test 3: Special characters
        let specialMessage = SlackMessage(
            timestamp: Date(),
            sender: "user",
            content: "Message with Ã©mojis ðŸŽ‰ and spÃ©cial chars Ã¥Ã§ÄÃ©Ã±ts",
            threadId: nil,
            messageType: .regular
        )
        
        if !specialMessage.contentHash.isEmpty {
            print("âœ… Special characters test passed")
        } else {
            print("âŒ Special characters test failed")
            passed = false
        }
        
        return passed
    }
}

// MARK: - Test Utilities

extension SlackIntegrationTests {
    
    /// Create a sample conversation for testing
    public static func createSampleConversation() -> SlackConversation {
        let messages = [
            SlackMessage(
                timestamp: Date(timeIntervalSinceNow: -300),
                sender: "alice",
                content: "Welcome to the new project @everyone!",
                metadata: SlackMessage.MessageMetadata(mentions: ["@everyone"])
            ),
            SlackMessage(
                timestamp: Date(timeIntervalSinceNow: -240),
                sender: "bob", 
                content: "Thanks Alice! I've uploaded the initial specs.pdf",
                metadata: SlackMessage.MessageMetadata(attachmentNames: ["specs.pdf"])
            ),
            SlackMessage(
                timestamp: Date(timeIntervalSinceNow: -180),
                sender: "charlie",
                content: "Great start! ðŸš€",
                metadata: SlackMessage.MessageMetadata(reactions: ["ðŸš€": 3])
            )
        ]
        
        return SlackConversation(
            workspace: "acme-corp",
            channel: "#project-alpha",
            channelType: .publicChannel,
            messages: messages
        )
    }
}